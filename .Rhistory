# [1] "birthweight" "head"   "height"    "gestage"   "m_age"    "m_height"
# der numerischen Variablen und die Funktion FUN erstellt für jede dieser
# Variablen v einen Boxplot getrennt nach firstborn.
# Über das Argument v der Funktion FUN wird hier je ein Variablenname
# aus names(numerisch)[numerisch] der Reihe nach an FUN übergeben.
# [1] "birthweight" "head"   "height"    "gestage"   "m_age"    "m_height"
# der numerischen Variablen und die Funktion FUN erstellt für jede dieser
# Variablen v einen Boxplot getrennt nach firstborn.
# Über das Argument v der Funktion FUN wird hier je ein Variablenname
# aus names(numerisch)[numerisch] der Reihe nach an FUN übergeben.
# [1] "birthweight" "head"   "height"    "gestage"   "m_age"    "m_height"
# der numerischen Variablen und die Funktion FUN erstellt für jede dieser
# Variablen v einen Boxplot getrennt nach firstborn.
# Über das Argument v der Funktion FUN wird hier je ein Variablenname
# aus names(numerisch)[numerisch] der Reihe nach an FUN übergeben.
numerisch
10-0.5
load("C:/Users/Jacqu/Documents/Schätzen und Testen/Abgaben/pflanzen.RData")
load("C:/Users/Jacqu/Documents/Schätzen und Testen/Abgaben/pflanzen.RData")
X <- matrix(c(1, -1, -1, 1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)nrow=8, ncol = 4)
X <- matrix(c(1, -1, -1, 1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),nrow=8, ncol = 4)
length(c(1, -1, -1, 1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1))
8*4
X <- matrix(c(1, -1, -1, 1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),nrow=8, ncol = 4)
X
X <- matrix(c(1,1,1,1,1,1,1,1, -1,-1,-1,-1,1,1,1,1, -1,-1,1,1,-1,-1,1,1, -1,-1,1,1,-1,-1,1,1, 1,1,-1,-1,-1,-1,1,1,  nrow=8, ncol = 4)
)
)
X <- matrix(c(1,1,1,1,1,1,1,1, -1,-1,-1,-1,1,1,1,1, -1,-1,1,1,-1,-1,1,1, -1,-1,1,1,-1,-1,1,1, 1,1,-1,-1,-1,-1,1,1), nrow=8, ncol = 4)
length(c(1,1,1,1,1,1,1,1, -1,-1,-1,-1,1,1,1,1, -1,-1,1,1,-1,-1,1,1, -1,-1,1,1,-1,-1,1,1, 1,1,-1,-1,-1,-1,1,1))
length(1,1,1,1,1,1,1,1)
length(-1,-1,-1,-1,1,1,1,1)
length(-1,-1,1,1,-1,-1,1,1)
length(-1,-1,1,1,-1,-1,1,1,)
length(c( -1,-1,1,1,-1,-1,1,1))
length(c(1,1,-1,-1,-1,-1,1,1))
X <- matrix(c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1), nrow=8, ncol = 4)
length(c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1))
X <- matrix(c(1,1,1,1,1,1,1,1, -1,-1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1), nrow=8, ncol = 4, byrow=T)
X <- matrix(c(1,1,1,1,1,1,1,1, -1,-1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1), nrow=8, ncol = 4, byrow=F)
matrix(c(1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1), nrow=8, ncol=5)
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1), nrow=8, ncol=5)
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1), nrow=8, ncol=5)
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1), nrow=8, ncol=5)
X
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1,), nrow=8, ncol=4)
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1), nrow=8, ncol=4)
matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1,
-1, -1, 1, 1, -1, -1, 1, 1,
1, 1, -1, -1, 1, 1, -1, -1), nrow = 8, ncol = 4, byrow = TRUE)
matrix(c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1), nrow=8, ncol = 4, byrow=Theoph)
matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1,
-1, -1, 1, 1, -1, -1, 1, 1,
1, 1, -1, -1, 1, 1, -1, -1), nrow = 8, ncol = 4, byrow = TRUE)
matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1,
-1, -1, 1, 1, -1, -1, 1, 1,
1, 1, -1, -1, 1, 1, -1, -1), nrow = 8, ncol = 4, byrow = F)
diagmatrix <- diag(8, nrow=4, ncol=4)
diagmatrix
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1,
-1, -1, 1, 1, -1, -1, 1, 1,
1, 1, -1, -1, 1, 1, -1, -1), nrow = 8, ncol = 4, byrow = F)
diagmatrix <- diag(8, nrow=4, ncol=4)
y <- c(-1,-1,-1,-1,1,1,1,1)
kqs <- solve(diagmatrix) %*% transpose(X) %*% y
kqs <- solve(diagmatrix) %*% t(X) %*% y
kqs
y <- c(5, 5, 3, 5, 3, 7, 10, 12)
X <- matrix(c(1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1), nrow = 8, ncol = 4)
theta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
t(X) %*% X
X
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1,
-1, -1, 1, 1, -1, -1, 1, 1,
1, 1, -1, -1, 1, 1, -1, -1), nrow = 8, ncol = 4, byrow = F)
theta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
y
y <- c(5,5,3,5,3,7,10,12)
kqs <- solve(diagmatrix) %*% t(X) %*% y
(kqs <- solve(diagmatrix) %*% t(X) %*% y)
1.75*2
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1,
-1, -1, 1, 1, -1, -1, 1, 1,
1, 1, -1, -1, 1, 1, -1, -1), nrow = 8, ncol = 4, byrow = F)
diagmatrix <- diag(8, nrow=4, ncol=4)
y <- c(5,5,3,5,3,7,10,12)
(kqs <- solve(diagmatrix) %*% t(X) %*% y)
1/4*t(y- (X%*%kqs))%*%(y- (X%*%kqs))
-1, -1, -1, -1, 1, 1, 1, 1, nrow = 8, ncol = 2, byrow = F)
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1), nrow = 8, ncol = 2, byrow = F)
X
X_2 <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1), nrow = 8, ncol = 2, byrow = F)
X_2
(kqs2 <- solve(t(X)%*% X) %*% t(X) %*% y)
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1,
-1, -1, 1, 1, -1, -1, 1, 1,
1, 1, -1, -1, 1, 1, -1, -1), nrow = 8, ncol = 4, byrow = F)
X
L_2 <- matrix(c(1,0,0,0,
0, 1,0,0), nrow=2, ncol=4, byrow=F)
(L_2 <- matrix(c(1,0,0,0,
0, 1,0,0), nrow=2, ncol=4, byrow=F))
(L_2 <- matrix(c(1,0,0,0,
0,1,0,0), nrow=2, ncol=4, byrow=T))
X_2
(L_2 <- matrix(c(1,0,0,0,
0,1,0,0), nrow=2, ncol=4, byrow=T))
(cov2 <- 12.25*L_2%*%solve(diagmatrix)%*%t(L_2))
(L_1 <- matrix(c(1,0,0,1), nrow=2, ncol=2, byrow=T))
(cov_1 <- L_1%*%solve(t(X_2)%*%X_2)%*%L1)
(L_1 <- matrix(c(1,0,0,1), nrow=2, ncol=2, byrow=T))
(cov_1 <- L_1%*%solve(t(X_2)%*%X_2)%*%L1)
(cov_1 <- L_1%*%solve(t(X_2)%*%X_2)%*%L_1)
0.125*12
0.125*12.25
(L_2 <- matrix(c(1,0,0,0,
0,1,0,0), nrow=2, ncol=4, byrow=T))
(cov_2 <- 12.25*L_2%*%solve(diagmatrix)%*%t(L_2))
load("C:/Users/Jacqu/Documents/Schätzen und Testen/Abgaben/pflanzen.RData")
View(pflanzen)
setwd("C:/Users/Jacqu/Documents/R Übung/Blatt13_30.01.2024")
# mit "[[:alpha:]]" und value = TRUE werden alle Werte angezeigt,
# die Buchstaben enthalten:
grep("[[:alpha:]]", birth$gestage, value = TRUE)
setwd("C:/Users/Jacqu/Documents/R Übung/Blatt13_30.01.2024")
load("birth_original.RData", verbose = T)
# Entferne "g" am Ende der Zeichenkette:
birth$birthweight <- gsub("g$", "", birth$birthweight)
# oder alle Buchstaben:
birth$birthweight <- gsub("[[:alpha:]]", "", birth$birthweight)
birth$birthweight <- as.numeric(birth$birthweight)
str(birth)
### b) Ersetze "," durch "." in head:
birth$head <- gsub(",", ".", birth$head)
birth$head <- as.numeric(birth$head)
### b) Ersetze "," durch "." in head:
birth$head <- gsub(",", ".", birth$head)
birth$head <- as.numeric(birth$head)
str(birth)
# "[" und "]" sind Metacharacters, die eine spezielle Bedeutung
# in Regular Expressions haben (siehe z.B. a)). Wenn diese tatsächlich
# ersetzen möchte, muss man dies durch Doppelbackslash kenntlich machen:
birth$height <- gsub(" \\[cm\\]", "", birth$height)
birth$height <- as.numeric(birth$height)
str(birth)
# mit "[[:alpha:]]" und value = TRUE werden alle Werte angezeigt,
# die Buchstaben enthalten:
grep("[[:alpha:]]", birth$gestage, value = TRUE)
?grep
# grepl gibt einen logischen Vektor zurück, der uns hier mit TRUE anzeigt,
# wo die Werte mit Buchstaben stehen:
str(grepl("[[:alpha:]]", birth$gestage))
# Auf NA setzen:
is.na(birth$gestage[grepl("[[:alpha:]]", birth$gestage)]) <- TRUE
birth$gestage <- as.numeric(birth$gestage)
str(birth)
# hier gibt es unterschiedlich viele Leerzeichen vor bzw. nach der Ausprägung
unique(birth$sex)
# trim white space:
birth$sex <- trimws(birth$sex)
unique(birth$sex)
birth$sex <- factor(birth$sex)
table(birth$firstborn)  # mal groß, mal klein geschriebene Ausprägungen
birth$firstborn <- tolower(birth$firstborn)
table(birth$firstborn)
birth$firstborn <- factor(birth$firstborn)
str(birth)
# Prüfe, ob da irgendwo etwas anderes drin steht als eine Zahl:
any(grepl("[^[:digit:]_]", birth$m_height)) # [1] TRUE
# oder: Ziffern von Anfang "^" bis Ende "$", Anzahl Ziffern mind. 1: "+"
any(!grepl("^[[:digit:]]+$", birth$m_height)) # [1] TRUE
## Uebungsblatt 13 (12 Punkte)
## Abgabe von Uwe Ligges und Swetlana Herbrandt
## hmmm okay
####################################################################
###                                                              ###
###        Aufgabe 33 -- Zeichenketten: Datensatzbereinigung     ###
###   0.5 + 0.5 + 1 + 1 + 1 + 0.5 + 1.5 + 1.5 + 2 = 9.5 Punkte   ###
###                                                              ###
####################################################################
setwd("C:/Users/Jacqu/Documents/R Übung/Blatt13_30.01.2024")
load("birth_original.RData", verbose = T)
### a) Entferne die Einheit g in birthweight:
# Entferne "g" am Ende der Zeichenkette:
birth$birthweight <- gsub("g$", "", birth$birthweight)
# oder alle Buchstaben:
birth$birthweight <- gsub("[[:alpha:]]", "", birth$birthweight)
birth$birthweight <- as.numeric(birth$birthweight)
str(birth)
### b) Ersetze "," durch "." in head:
birth$head <- gsub(",", ".", birth$head)
birth$head <- as.numeric(birth$head)
str(birth)
### c) Entferne die Einheit [cm] in height:
# "[" und "]" sind Metacharacters, die eine spezielle Bedeutung
# in Regular Expressions haben (siehe z.B. a)). Wenn diese tatsächlich
# ersetzen möchte, muss man dies durch Doppelbackslash kenntlich machen:
birth$height <- gsub(" \\[cm\\]", "", birth$height)
birth$height <- as.numeric(birth$height)
str(birth)
### d) Nicht hilfreiche Angaben auf NA setzen:
# mit "[[:alpha:]]" und value = TRUE werden alle Werte angezeigt,
# die Buchstaben enthalten:
grep("[[:alpha:]]", birth$gestage, value = TRUE)
# [1] "nicht eingetragen"                   "nicht bekannt"
# [3] "Handschrift im Pat.Akte unleserlich"
# ohne value = TRUE erhalten wir die Indizes, in denen Werte mit Buchstaben stehen:
grep("[[:alpha:]]", birth$gestage)
#[1] 129 679 836
# grepl gibt einen logischen Vektor zurück, der uns hier mit TRUE anzeigt,
# wo die Werte mit Buchstaben stehen:
str(grepl("[[:alpha:]]", birth$gestage))
# [1] FALSE FALSE FALSE FALSE FALSE .... TRUE ....
# Auf NA setzen:
is.na(birth$gestage[grepl("[[:alpha:]]", birth$gestage)]) <- TRUE
birth$gestage <- as.numeric(birth$gestage)
str(birth)
### e) Variable sex soll ein Faktor mit den Ausprägungen "male" und "female" werden:
# hier gibt es unterschiedlich viele Leerzeichen vor bzw. nach der Ausprägung
unique(birth$sex)
# hier gibt es unterschiedlich viele Leerzeichen vor bzw. nach der Ausprägung
unique(birth$sex)
# trim white space:
birth$sex <- trimws(birth$sex)
unique(birth$sex)
birth$sex <- factor(birth$sex)
str(birth)
table(birth$firstborn)  # mal groß, mal klein geschriebene Ausprägungen
birth$firstborn <- tolower(birth$firstborn)
table(birth$firstborn)
birth$firstborn <- factor(birth$firstborn)
str(birth)
# Prüfe, ob da irgendwo etwas anderes drin steht als eine Zahl:
any(grepl("[^[:digit:]_]", birth$m_height)) # [1] TRUE
# oder: Ziffern von Anfang "^" bis Ende "$", Anzahl Ziffern mind. 1: "+"
any(!grepl("^[[:digit:]]+$", birth$m_height)) # [1] TRUE
# was genau steht da:
grep("[^[:digit:]_]", birth$m_height, value = TRUE)
# oder
grep("^[[:digit:]]+$", birth$m_height, value = TRUE, invert = TRUE)
# Ausgehend davon, dass man sich offenbar beim Wert nicht sicher ist,
# setzen wir diese auf NA:
is.na(birth$m_height[grep("\\?$", birth$m_height)]) <- TRUE
birth$m_height <- as.numeric(birth$m_height)
str(birth)
# alle Zeilennamen:
rn <- rownames(birth)
rn[1:5]
# Wir wollen nun einen Teil (den Teil, der in den runden Klammern steht) der Zeichenkette extrahieren.
# Die Zeichenkette beginnt ("^") mit genau 6 Zeichen, die entweder Buchstaben oder
# Zahlen sind, gefolgt von einem "_": "^[[:alnum:]]{6}_"
# alles (".*"), was danach kommt wollen wir ausgegeben haben ("\\1"):
gebzeit <- gsub("^[[:alnum:]]{6}_(.*)", "\\1", rn)
gebzeit
# Lösung über substring:
str(substring(rn, 8, nchar(rn[1])))
# Zeitobjekt erstellen und im Datensatz speichern:
birth$birthtime <- as.POSIXct(gebzeit, format = "%Y_%m_%d_%H_%M_%S")
str(birth)
# Prüfe, ob da irgendwo etwas anderes drin steht als eine Zahl:
any(grepl("[^[:digit:]_]", birth$m_age)) # [1] TRUE
# was genau steht da:
grep("[^[:digit:]_]", birth$m_age, value = TRUE)
## Bestimme mit Hilfe von birthtime das Alter der Mutter zum Zeitpunkt der Geburt:
# welche Angaben sind betroffen:
w <- grep("[^[:digit:]_]", birth$m_age)
w
# Geburtsdaten herausschreiben:
gebdatum_Mutter <- birth$m_age[w]
gebdatum_Mutter
# Umwandeln in eine Datumsobjekt:
gebdatum_Mutter <- as.Date(gebdatum_Mutter, format = "%d. %B %Y")
# Geburtsdatum des Kindes ermitteln
gebdatum_Kind <- as.Date(birth$birthtime[w])
# Alter der Mutter zum Zeitpunkt der Geburt berechnen:
# approximative Lösung:
as.integer(floor(difftime(gebdatum_Kind, gebdatum_Mutter) / 365.2425))
as.integer(format(gebdatum_Kind, "%Y"))
as.integer(format(gebdatum_Mutter, "%Y")) -0
(format(gebdatum_Kind, "%m-%d")
)
load("birth.RData", verbose = TRUE)
### a) Daten um das Geburtsdataum ergänzen:
birth$birthdate <- as.Date(birth$birthtime)
(kqs <- solve(diagmatrix) %*% t(X) %*% y)
X
X <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1,
-1, -1, 1, 1, -1, -1, 1, 1,
1, 1, -1, -1, -1, -1, 1, 1), nrow = 8, ncol = 4, byrow = F)
diagmatrix <- diag(8, nrow=4, ncol=4)
y <- c(5,5,3,5,3,7,10,12)
(kqs <- solve(diagmatrix) %*% t(X) %*% y)
1/4*t(y- (X%*%kqs))%*%(y- (X%*%kqs))
1/4*t(y- (X%*%kqs))%*%(y- (X%*%kqs))
X_2 <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1,
-1, -1, -1, -1, 1, 1, 1, 1), nrow = 8, ncol = 2, byrow = F)
(kqs2 <- solve(t(X)%*% X) %*% t(X) %*% y)
(L_1 <- matrix(c(1,0,0,1), nrow=2, ncol=2, byrow=T))
(cov_1 <- L_1%*%solve(t(X_2)%*%X_2)%*%L_1)
(L_2 <- matrix(c(1,0,0,0,
0,1,0,0), nrow=2, ncol=4, byrow=T))
(cov_2 <- 12.25*L_2%*%solve(diagmatrix)%*%t(L_2))
(cov_2 <- 3*L_2%*%solve(diagmatrix)%*%t(L_2))
3*0.25
3*0.125
X
# oder
grep("^[[:digit:]]+$", birth$m_height, value = TRUE, invert = TRUE)
# was genau steht da:
grep("[^[:digit:]_]", birth$m_height, value = TRUE)
## Abgabe von Uwe Ligges und Swetlana Herbrandt
## hmmm okay
####################################################################
###                                                              ###
###        Aufgabe 33 -- Zeichenketten: Datensatzbereinigung     ###
###   0.5 + 0.5 + 1 + 1 + 1 + 0.5 + 1.5 + 1.5 + 2 = 9.5 Punkte   ###
###                                                              ###
####################################################################
setwd("C:/Users/Jacqu/Documents/R Übung/Blatt13_30.01.2024")
load("birth_original.RData", verbose = T)
### a) Entferne die Einheit g in birthweight:
# Entferne "g" am Ende der Zeichenkette:
birth$birthweight <- gsub("g$", "", birth$birthweight)
# oder alle Buchstaben:
birth$birthweight <- gsub("[[:alpha:]]", "", birth$birthweight)
birth$birthweight <- as.numeric(birth$birthweight)
str(birth)
### b) Ersetze "," durch "." in head:
birth$head <- gsub(",", ".", birth$head)
birth$head <- as.numeric(birth$head)
str(birth)
### c) Entferne die Einheit [cm] in height:
# "[" und "]" sind Metacharacters, die eine spezielle Bedeutung
# in Regular Expressions haben (siehe z.B. a)). Wenn diese tatsächlich
# ersetzen möchte, muss man dies durch Doppelbackslash kenntlich machen:
birth$height <- gsub(" \\[cm\\]", "", birth$height)
birth$height <- as.numeric(birth$height)
str(birth)
### d) Nicht hilfreiche Angaben auf NA setzen:
# mit "[[:alpha:]]" und value = TRUE werden alle Werte angezeigt,
# die Buchstaben enthalten:
grep("[[:alpha:]]", birth$gestage, value = TRUE)
# [1] "nicht eingetragen"                   "nicht bekannt"
# [3] "Handschrift im Pat.Akte unleserlich"
# ohne value = TRUE erhalten wir die Indizes, in denen Werte mit Buchstaben stehen:
grep("[[:alpha:]]", birth$gestage)
#[1] 129 679 836
# grepl gibt einen logischen Vektor zurück, der uns hier mit TRUE anzeigt,
# wo die Werte mit Buchstaben stehen:
str(grepl("[[:alpha:]]", birth$gestage))
# [1] FALSE FALSE FALSE FALSE FALSE .... TRUE ....
# Auf NA setzen:
# Auf NA setzen:
is.na(birth$gestage[grepl("[[:alpha:]]", birth$gestage)]) <- TRUE
birth$gestage <- as.numeric(birth$gestage)
# hier gibt es unterschiedlich viele Leerzeichen vor bzw. nach der Ausprägung
unique(birth$sex)
# trim white space:
birth$sex <- trimws(birth$sex)
unique(birth$sex)
birth$sex <- factor(birth$sex)
str(birth)
table(birth$firstborn)  # mal groß, mal klein geschriebene Ausprägungen
birth$firstborn <- tolower(birth$firstborn)
table(birth$firstborn)
birth$firstborn <- factor(birth$firstborn)
str(birth)
# Prüfe, ob da irgendwo etwas anderes drin steht als eine Zahl:
any(grepl("[^[:digit:]_]", birth$m_height)) # [1] TRUE
# oder: Ziffern von Anfang "^" bis Ende "$", Anzahl Ziffern mind. 1: "+"
any(!grepl("^[[:digit:]]+$", birth$m_height)) # [1] TRUE
grepl("[^[:digit:]_]", birth$m_height)
table(birth$firstborn)  # mal groß, mal klein geschriebene Ausprägungen
mosaicplot(~ factor(`UB(V)`, levels = c(1,0), labels = c("Genutzt", "Nicht genutzt")) +
factor(`Ersatzbew. (10)`, levels = c(1,0), labels = c("Ja", "Nein")),
data = data, ylab = "Ersatz ausreichend", xlab= "Universitäts-Bibiliothek", col = c("springgreen3", "royalblue2"), main = " ")
library("readxl")
data <- read_excel("C:/Users/Jacqu/Documents/Erhebungstechniken/Bericht/DatensatzFragebogenLJJY.xlsx")
mosaicplot(~ factor(`UB(V)`, levels = c(1,0), labels = c("Ja", "Nein")) +
factor(`Ersatzbew. (10)`, levels = c(1,0), labels = c("Ja", "Nein")),
data = data, ylab = "Ersatz ausreichend", xlab= "Bibliothek benutzt",
main = "Ersatzbewertung")
#barplot(table(data$`Ersatzbew. (10)`))
#data$`Ersatzbew. (10)` <- factor(data$`Ersatzbew. (10)`, levels = c(1,0), labels = c("Ja", "Nein"))
#barplot(table(data$`Ersatzbew. (10)`))
windows()
mosaicplot(~ factor(`UB(V)`, levels = c(1,0), labels = c("Ja", "Nein")) +
factor(`Ersatzbew. (10)`, levels = c(1,0), labels = c("Ja", "Nein")),
data = data, ylab = "Ersatz ausreichend", xlab= "Bibliothek benutzt",
main = "Ersatzbewertung")
locator(1)
#barplot(table(data$`Ersatzbew. (10)`))
#data$`Ersatzbew. (10)` <- factor(data$`Ersatzbew. (10)`, levels = c(1,0), labels = c("Ja", "Nein"))
#barplot(table(data$`Ersatzbew. (10)`))
windows()
mosaicplot(~ factor(`UB(V)`, levels = c(1,0), labels = c("Ja", "Nein")) +
factor(`Ersatzbew. (10)`, levels = c(1,0), labels = c("Ja", "Nein")),
data = data, ylab = "Ersatz ausreichend", xlab= "Bibliothek benutzt",
main = "Ersatzbewertung")
windows()
# mai = c(0, 0, 0, 0):  verhindert den weissen Rand
# bty = "n":            keine Box
# ann = FALSE:          keine Achsenbeschriftung
# lwd = 4:              Linienbreite 4
# bg = "cadetblue3":    Hintergrundfarbe
op <- par(mai = c(0, 0, 0, 0), bty = "n", ann = FALSE, lwd = 4, bg = "cadetblue3")
## leeren Plot erstellen
plot(NULL, xlim = c(-7, 7), ylim = c(0, 20), bty = "n", asp = 1, axes = FALSE)
### b) Boden:
polygon(c(-15, -15, 15, 15), c(-1, 2, 2, -1), col = "white", border = "white")
### c) Baumstamm:
polygon(c(-1, -1, 1, 1), c(1.5, 3.5, 3.5, 1.5), col = "tan4", border = "tan4")
# Erstelle ein Kreissegemnt mit Radius 1 im Punkt (0,0):
kreissegment <- cbind(c(0, cos(seq(-3/4*pi, -1/4*pi, le = 100)), 0), c(0, sin(seq(-3/4*pi, -1/4*pi, le = 100)), 0))
# Passe die Kreissegmente an: Radius * kreissegment + position:
# statt cbind(0, rep(13, le = 102)) geht auch t(t(rep(1,102))) %*% t(c(0, 13)) oder matrix(rep(1,102), ncol=1) %*% c(0, 13)
polygon(10 * kreissegment + cbind(0, rep(13,   le = 102)),   col = "forestgreen", border = "darkgreen")
polygon(7  * kreissegment + cbind(0, rep(15,   le = 102)),   col = "forestgreen", border = "darkgreen")
polygon(5  * kreissegment + cbind(0, rep(17.5, le = 102)), col = "forestgreen", border = "darkgreen")
# density --> Dichte der Streifen
# angle   --> Winkel der Streifen
# col     --> Farbe des Rechtecks
# border  --> Farbe des Rechteckrandes
# lty     --> Linientyp
rect(xleft = -6.5, ybottom = 1, xright = -3, ytop = 3, col = "goldenrod1", border = "firebrick1")
rect(xleft = -6.5, ybottom = 1, xright = -3, ytop = 3, density = 10, col = "firebrick1")
rect(xleft = -5, ybottom = 0.5, xright = -2, ytop = 2.5, col = "chartreuse3", border = "gold1")
rect(xleft = -5, ybottom = 0.5, xright = -2, ytop = 2.5, density = 10, lty = 3, angle = 0, col = "gold1")
rect(xleft = 0.5, ybottom = 0.8, xright = 5, ytop = 2.8, col = "yellow", border = "cadetblue4")
rect(xleft = 0.5, ybottom = 0.8, xright = 5, ytop = 2.8, density = 5, angle = 90, col = "cadetblue4")
rect(xleft = 0.5, ybottom = 0.8, xright = 5, ytop = 2.8, density = 5, angle = 0,  col = "cadetblue4")
## Stern (extra):
tannenspizte <- 5  * kreissegment + cbind(0, rep(17.5, le = 102))
text(0, max(tannenspizte[,2]) + 1, labels = "\U272D", col = "gold1", cex = 10)
deko <- function(dekoElemente, farbPalette){
cat("\n\nMarkiere Positionen für:\n")  # Schreibe Infomationstext
print(dekoElemente)                    # printe die Dekoelemente
flush.console()                        # bewirkt, dass alles sofort in die Console geschrieben wird
# i) Anzahl dekoElemente bestimmen:
n <- length(dekoElemente)
# ii) Bestimme so viele Koordinaten wie es dekoElemente gibt:
coords <- locator(n)
# iii) Male die dekoElemente an die Koordinatenstellen in coords:
text(coords, labels = dekoElemente,
col = farbPalette(n),   # in den Farben der farbPalette
cex = seq(3,4, le = n)) # und in unterschiedlichen Größen
# Die Funktion gibt die Koordinaten zurück, die jedoch nicht geprintet werden
# (wird durch invisible() bewirkt):
return(invisible(coords))
}
### b) Weihnachtlichen Farbpalette erstellen:
# Funktion, die n Farben generiert, angefangen mit "chartreuse3" über "gold" bis hin zu "firebrick3"
farbPalette <- colorRampPalette(c("chartreuse3", "gold", "firebrick3"))
str(farbPalette) # function (n)   --> Funktion mit Argument n
farbPalette(2)   # [1] "#66CD00" "#CD2626"           --> zwei Farben
farbPalette(3)   # [1] "#66CD00" "#FFD700" "#CD2626" --> drei Farben
# 1. Weihnachsschmuck - Box:
box1 <- c("\U2743", "\U273B", "\U2737", "\U2728", "\U2745", "\U1F36D", "\U1F380")
deko(dekoElemente = box1, farbPalette = farbPalette)
# 2. Weihnachsschmuck - Box:
box2 <- expression(alpha, beta, gamma, delta, mu, omega)
deko(dekoElemente = box2, farbPalette = farbPalette)
# Schneeflocken (extra):
flocke <- "\U2744"
farbPaletteFlocke <- colorRampPalette("white")  # alle Flocken in weißer Farbe
deko(dekoElemente = rep(flocke, 10), farbPalette = farbPaletteFlocke)
library(tikzDevice)
dev.off()
library(tikzDevice)
tikz('Mosaic.tex', width=4.3,height=3.8)
library("readxl")
data <- read_excel("C:/Users/Jacqu/Documents/Erhebungstechniken/Bericht/DatensatzFragebogenLJJY.xlsx")
setwd("C:/Users/Jacqu/Documents/GitHub/Bericht-ET")
# 3: Stichprobe und Datensatz
# Erhebung: Aushaendigen von Boegen und online Ausfuellen
# Ort: Campus, Lernorte der TU (Fokus: Galerie, Mathetower)
# Zeitraum: 13.11. bis 26.11.2023
# Stichprobe: 141 eingereichte Frageboegen, aber
nrow(data)
drop = c(41, 69)
data = data[-drop, ]
rm(drop)
nrow(data) # 139 verwertbare Daten
ncol(data)
# davon Nicht-TU-Studenten und Erstis ebenfalls loeschen
data = data[-which(data[ ,64] == 0), ]
nrow(data) # also nur noch 138 verwertbare
#barplot(table(data$`Ersatzbew. (10)`))
#data$`Ersatzbew. (10)` <- factor(data$`Ersatzbew. (10)`, levels = c(1,0), labels = c("Ja", "Nein"))
#barplot(table(data$`Ersatzbew. (10)`))
mosaicplot(~ factor(`UB(V)`, levels = c(1,0), labels = c("Ja", "Nein")) +
factor(`Ersatzbew. (10)`, levels = c(1,0), labels = c("Ja", "Nein")),
data = data, ylab = "Ersatz ausreichend", xlab= "Bibliothek benutzt",
main = "Ersatzbewertung")
dev.off()
library(tikzDevice)
tikz('Mosaic.tex', width=4.3,height=3.8)
mosaicplot(~ factor(`SB(J)`, levels = c(1,0), labels = c("Genutzt", "Nicht genutzt")) +
factor(`Ersatzbew. (10)`, levels = c(1,0), labels = c("Ja", "Nein")),
data = data, ylab = "Ersatzbewertung ausreichend", xlab= "Nutzung der Sebrath-Bibliothek",
col = c("springgreen3", "royalblue2"), main = "Bewertung im Kontext der Sebrath Bibliothek")
dev.off()
